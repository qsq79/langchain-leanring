# 企业级多智能体客服系统 - 项目结构说明文档

## 1. 项目概述

### 1.1 项目简介

本项目是基于 AutoGen 框架构建的企业级多智能体客服系统，旨在通过多个专业智能体协同工作来处理客户服务问题。系统能够自动处理客户关于订单状态和物流信息的查询，并提供智能化的回复服务，显著提升客服效率和用户体验。

**项目背景**：
当前客服系统需要处理大量关于订单状态和物流信息的用户查询。传统方式需要人工查询多个系统接口，效率低下且容易出错。基于 AutoGen 框架的多智能体客服系统可以通过多个专门智能体协同工作，自动化处理这些查询请求，提高响应速度和准确性。

**项目目标**：
- 自动化处理用户关于订单状态和物流信息的查询
- 通过多个智能体协同工作完成复杂查询任务
- 提供用户友好的智能回复
- 提高客服响应效率和准确性
- 实现智能体交互过程可视化
- 支持接口调用的自动重试机制

### 1.2 核心功能

#### 1.2.1 功能模块

| 功能模块 | 功能描述 | 涉及智能体 | 优先级 |
|---------|---------|-----------|--------|
| 订单状态查询 | 根据订单编号查询订单的详细状态信息，包括创建时间、订单状态、支付状态、发货状态等 | Agent A（订单查询智能体） | 高 |
| 物流信息查询 | 查询订单的物流跟踪信息，包括物流状态、运输轨迹、当前位置、预计送达时间等 | Agent B（物流查询智能体） | 高 |
| 多智能体协同 | 多个智能体协同工作，通过消息传递机制完成复杂查询任务 | 所有智能体 | 高 |
| 智能回复生成 | 整合订单状态和物流信息，理解用户查询意图，生成用户友好的自然语言回复 | Agent C（结果汇总智能体） | 高 |
| 交互过程可视化 | 实时显示智能体之间的交互过程，包括消息传递、任务分配、结果汇总等 | 交互可视化展示器 | 中 |
| 接口调用重试 | 处理 API 调用失败情况，采用指数级退避策略自动重试失败的请求 | 重试机制服务 | 高 |
| 用户查询输入 | 提供用户输入查询问题的接口，支持命令行参数输入和交互式输入两种方式 | 用户输入处理器 | 中 |

#### 1.2.2 功能特点

- **订单状态查询**：Agent A 负责查询订单的详细状态信息
- **物流信息检查**：Agent B 负责获取订单的物流跟踪信息
- **结果汇总回复**：Agent C 负责整合信息并生成用户友好的回复
- **自动重试机制**：支持指数级退避的网络请求重试
- **详细交互展示**：实时显示智能体之间的交互过程
- **智能意图理解**：自动识别用户查询意图，提取关键信息
- **并行处理能力**：订单查询和物流查询智能体可并行工作
- **友好的错误处理**：提供清晰的错误信息和重试提示

### 1.3 架构特点

#### 1.3.1 设计原则

- **单一职责原则**：每个智能体负责特定的查询任务，职责明确
- **开闭原则**：对扩展开放（可添加新智能体），对修改封闭（现有智能体核心逻辑稳定）
- **里氏替换原则**：智能体接口设计统一，不同智能体可互相替换
- **接口隔离原则**：智能体之间通过定义良好的接口进行通信
- **依赖倒置原则**：智能体依赖抽象接口而非具体实现

#### 1.3.2 技术特点

- **基于 AutoGen 框架的多智能体架构**
- **分层架构设计**：用户交互层、应用层、智能体层、服务层、数据层
- **异步处理和并发支持**：提高系统响应速度
- **完善的错误处理和重试机制**：采用指数级退避策略
- **丰富的命令行界面展示**：使用 Rich 库实现彩色终端输出
- **模块化设计**：易于扩展和维护
- **高可用性**：通过重试机制和错误处理策略确保系统稳定性
- **可扩展性**：支持轻松添加新的智能体类型和查询功能

### 1.4 技术栈

#### 1.4.1 核心框架

| 技术组件 | 版本要求 | 用途说明 |
|---------|---------|---------|
| **AutoGen** | >=0.2.0 | 多智能体框架，负责智能体的创建、管理和协调 |
| **FastAPI** | >=0.104.0 | 现代化的 Web API 框架，用于构建模拟内部系统 |
| **Uvicorn** | >=0.24.0 | ASGI 服务器，用于运行 FastAPI 应用 |

#### 1.4.2 数据处理

| 技术组件 | 版本要求 | 用途说明 |
|---------|---------|---------|
| **Pydantic** | >=2.5.0 | 数据验证和序列化 |
| **Pydantic-settings** | >=2.1.0 | 配置管理 |

#### 1.4.3 异步和网络

| 技术组件 | 版本要求 | 用途说明 |
|---------|---------|---------|
| **aiofiles** | >=23.2.0 | 异步文件操作 |
| **httpx** | >=0.25.0 | 现代化的异步 HTTP 客户端 |
| **tenacity** | >=8.2.0 | 重试机制库 |

#### 1.4.4 AI 和语言模型

| 技术组件 | 版本要求 | 用途说明 |
|---------|---------|---------|
| **OpenAI** | >=1.3.0 | OpenAI API 客户端，用于自然语言生成 |

#### 1.4.5 用户界面和工具

| 技术组件 | 版本要求 | 用途说明 |
|---------|---------|---------|
| **Rich** | >=13.7.0 | 丰富的命令行界面库，实现彩色输出和进度条 |
| **Colorama** | >=0.4.6 | 跨平台彩色终端输出 |
| **Python-dotenv** | >=1.0.0 | 环境变量管理 |

#### 1.4.6 开发和测试

| 技术组件 | 版本要求 | 用途说明 |
|---------|---------|---------|
| **Pytest** | >=7.4.0 | 测试框架 |
| **Pytest-asyncio** | >=0.21.0 | 异步测试支持 |
| **Black** | >=23.11.0 | 代码格式化工具 |

## 2. 系统架构设计

### 2.1 整体架构图

本项目采用分层架构设计，共分为五层：

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户交互层                                 │
│                    命令行界面 CLI                                │
└────────────────────────────┬────────────────────────────────────┘
                             │
┌────────────────────────────▼────────────────────────────────────┐
│                         应用层                                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐     │
│  │ 查询解析器   │  │ 用户输入处理器 │  │ 交互可视化展示器 │     │
│  └──────────────┘  └──────────────┘  └──────────────────┘     │
└────────────────────────────┬────────────────────────────────────┘
                             │
┌────────────────────────────▼────────────────────────────────────┐
│                        智能体层                                   │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────┐  │
│  │ 订单查询智能体   │  │ 物流查询智能体   │  │结果汇总智能体│  │
│  └──────────────────┘  └──────────────────┘  └──────────────┘  │
│                    ┌─────────────────┐                         │
│                    │ 智能体通信管理器 │                         │
│                    └─────────────────┘                         │
└────────────────────────────┬────────────────────────────────────┘
                             │
┌────────────────────────────▼────────────────────────────────────┐
│                         服务层                                   │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────┐  │
│  │ 订单状态模拟API  │  │ 物流信息模拟API  │  │ 重试机制服务 │  │
│  └──────────────────┘  └──────────────────┘  └──────────────┘  │
└────────────────────────────┬────────────────────────────────────┘
                             │
┌────────────────────────────▼────────────────────────────────────┐
│                         数据层                                   │
│  ┌──────────────┐  ┌──────────────────┐                         │
│  │ 模拟订单数据 │  │ 模拟物流数据     │                         │
│  └──────────────┘  └──────────────────┘                         │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 架构分层详细说明

#### 2.2.1 用户交互层

**职责**：提供用户与系统交互的界面和输入输出接口

**组件**：
- **命令行界面（CLI）**：
  - 使用 Python 标准库的 `argparse` 解析命令行参数
  - 使用 `input` 函数实现交互式输入
  - 支持两种输入方式：命令行参数输入和交互式输入

**功能特性**：
- 灵活的参数配置支持
- 用户友好的交互提示
- 错误信息的友好展示

#### 2.2.2 应用层

**职责**：协调各个模块，处理业务逻辑

**核心组件**：

##### 查询解析器
- **功能**：解析用户查询内容，提取订单编号和查询意图
- **实现位置**：`main.py` 或独立的查询解析模块
- **输入**：用户查询字符串
- **输出**：解析后的结构化数据（订单编号、查询意图）

##### 用户输入处理器
- **功能**：处理用户输入的格式转换和验证
- **实现位置**：`main.py`
- **职责**：
  - 验证输入格式
  - 转换输入数据类型
  - 过滤无效输入

##### 交互可视化展示器
- **功能**：实时展示智能体之间的交互过程和消息传递
- **实现位置**：集成在智能体通信管理器中
- **展示内容**：
  - 智能体间的消息传递记录
  - 每个智能体的任务执行状态（待处理、执行中、已完成）
  - API 调用的详细日志（包含时间戳、请求内容、响应内容）
  - 重试机制的执行情况（重试次数、退避时间）
  - 最终结果的生成过程

#### 2.2.3 智能体层

**职责**：实现多智能体协同工作，完成查询任务

**智能体定义**：

| 智能体名称 | 职责 | 技术栈 | 依赖服务 |
|----------|------|--------|----------|
| 订单查询智能体 | 接收订单编号，调用订单状态API获取订单详细信息 | AutoGen + Python | 订单状态模拟API |
| 物流查询智能体 | 接收订单编号，调用物流信息API获取物流跟踪数据 | AutoGen + Python | 物流信息模拟API |
| 结果汇总智能体 | 整合订单和物流信息，理解查询意图，生成自然语言回复 | AutoGen + OpenAI API | 订单查询智能体、物流查询智能体 |

**智能体间通信**：

- **通信框架**：AutoGen 消息传递机制
- **消息格式**：结构化 JSON 格式
- **消息类型**：
  - 任务分发消息
  - 查询请求消息
  - 结果返回消息
  - 状态同步消息

**协同工作流程**：

```
用户 查询解析器 智能体通信管理器 订单查询智能体 物流查询智能体 结果汇总智能体 订单状态API 物流信息API 可视化展示器
 │        │             │             │             │            │           │          │          │
 ├───────>│             │             │             │            │           │          │          │
 │解析查询│             │             │             │            │           │          │          │
 │        ├───────────> │             │             │            │           │          │          │
 │        │分发任务     │             │             │            │           │          │          │
 │        │             ├───────────> │             │            │           │          │          │
 │        │             │订单查询任务 │             │            │           │          │          │
 │        │             │             ├───────────> │            │           │          │          │
 │        │             │             ├────────────────────────> │           │          │          │
 │        │             │             │物流查询任务            │           │          │          │
 │        │             │             │             │            │           │          │          │
 │        │             │             │调用订单API             │           │          │          │
 │        │             │             │             │调用物流API            │          │          │
 │        │             │             │             │            │           │          │          │
 │        │             │             │<──────────┤            │           │          │          │
 │        │             │             │返回订单信息│           │          │          │          │
 │        │             │             │             │           │ 返回物流信息        │          │          │
 │        │             │             │<─────────────────────────┤          │          │          │
 │        │             │             │发送订单信息             │          │          │          │
 │        │             │             │             │           │          │          │          │
 │        │             │             ├───────────────────────────────────────> │          │          │
 │        │             │             │发送物流信息                       │          │          │
 │        │             │             │整合信息生成回复                   │          │          │
 │        │             │             │             │           │          │          │          │
 │        │             │             │             │           │          │ │发送交互日志│          │
 │        │             │             │<─────────────────────────────────────────────────┤          │
 │        │             │             │展示交互过程                       │                     │
 │        │             │             │                                     │ 自然语言回复         │
 │<───────│─────────────│─────────────│─────────────│───────────│──────────┤────────────────────┤
```

### 2.3 项目文件结构

```
multi-agent-customer-system/
├── .env.example                 # 环境变量配置示例文件 ⭐
├── main.py                      # 项目主入口文件 ⭐
├── requirements.txt             # Python 依赖包列表 ⭐
├── 项目描述.txt                 # 项目需求和场景描述
├── 项目结构说明文档.md          # 本文档 ⭐
│
├── agents/                      # 智能体模块目录 ⭐
│   ├── __init__.py
│   ├── order_query_agent.py    # 订单查询智能体实现 ⭐
│   ├── logistics_query_agent.py # 物流查询智能体实现 ⭐
│   ├── result_summary_agent.py # 结果汇总智能体实现 ⭐
│   └── agent_communicator.py   # 智能体通信管理器 ⭐
│
├── api/                         # API 服务模块目录 ⭐
│   ├── __init__.py
│   ├── main.py                 # FastAPI 主应用 ⭐
│   ├── routes/                 # API 路由模块
│   │   ├── __init__.py
│   │   ├── orders.py           # 订单状态API路由 ⭐
│   │   └── logistics.py        # 物流信息API路由 ⭐
│   ├── models/                 # 数据模型定义
│   │   ├── __init__.py
│   │   ├── order.py            # 订单数据模型 ⭐
│   │   └── logistics.py        # 物流数据模型 ⭐
│   └── data/                   # 模拟数据存储
│       ├── __init__.py
│       ├── orders_data.py      # 订单模拟数据 ⭐
│       └── logistics_data.py   # 物流模拟数据 ⭐
│
├── config/                      # 配置模块目录 ⭐
│   ├── __init__.py
│   ├── settings.py            # 项目配置管理 ⭐
│   ├── agents.py              # 智能体行为配置 ⭐
│   ├── retry.py               # 重试机制配置 ⭐
│   └── api.py                 # API服务配置 ⭐
│
├── core/                        # 核心功能模块目录 ⭐
│   ├── __init__.py
│   ├── logger.py              # 日志系统配置 ⭐
│   ├── query_parser.py       # 查询解析器 ⭐
│   └── visualizer.py          # 交互可视化展示器 ⭐
│
├── services/                    # 服务层模块目录 ⭐
│   ├── __init__.py
│   ├── retry_service.py       # 重试机制服务 ⭐
│   └── order_service.py       # 订单查询服务 ⭐
│
├── tools/                       # 工具模块目录 ⭐
│   ├── __init__.py
│   └── api_client.py          # API 客户端工具 ⭐
│
├── utils/                       # 工具函数目录 ⭐
│   ├── __init__.py
│   ├── retry.py               # 重试机制实现 ⭐
│   └── validators.py          # 数据验证工具 ⭐
│
├── middleware/                  # 中间件目录 ⭐
│   ├── __init__.py
│   └── error_handler.py       # 错误处理中间件 ⭐
│
├── tests/                       # 测试目录 ⭐
│   ├── __init__.py
│   ├── unit/                  # 单元测试
│   │   ├── __init__.py
│   │   ├── test_agents.py     # 智能体单元测试 ⭐
│   │   ├── test_api_client.py # API客户端测试 ⭐
│   │   └── test_retry.py      # 重试机制测试 ⭐
│   └── integration/           # 集成测试
│       ├── __init__.py
│       ├── test_api.py        # API集成测试 ⭐
│       └── test_workflow.py   # 工作流集成测试 ⭐
│
├── scripts/                     # 脚本工具目录 ⭐
│   ├── setup_env.sh           # 环境设置脚本 ⭐
│   ├── start_api.sh            # 启动API服务脚本 ⭐
│   └── test_api.sh             # API测试脚本 ⭐
│
├── docs/                        # 文档目录 ⭐
│   ├── design.md               # 架构设计文档 ⭐
│   ├── requirements.md         # 需求规格说明书 ⭐
│   ├── tasks.md                # 任务规划文档 ⭐
│   └── api.md                  # API接口文档 ⭐
│
├── logs/                        # 日志文件目录 ⭐
│   ├── app.log                # 应用主日志 ⭐
│   ├── api.log                # API服务日志 ⭐
│   └── agents.log             # 智能体日志 ⭐
│
└── venv/                        # Python 虚拟环境目录
    ├── Include/               # 头文件目录
    ├── Lib/                   # 库文件目录
    ├── Scripts/               # 可执行文件目录
    ├── pyvenv.cfg             # 虚拟环境配置
    └── share/                 # 共享文件目录
```

### 2.4 关键文件详细说明

#### 🔥 核心入口文件

**`main.py`**: 项目主入口，负责启动服务、解析命令行参数、协调各模块工作

**主要功能**：
- 支持命令行参数解析（使用 `argparse`）
- 启动 FastAPI 模拟服务
- 初始化 AutoGen 智能体
- 处理用户查询请求
- 协调各模块之间的交互

**关键实现**：
```python
# 支持的命令行参数
--query: 指定查询内容
--interactive: 启用交互式输入模式
--log-level: 设置日志级别 (DEBUG, INFO, WARNING, ERROR)
```

#### 🤖 智能体模块

**`agents/order_query_agent.py`**: 订单查询智能体实现

**主要功能**：
- 基于 AutoGen 框架构建
- 接收订单编号作为输入
- 调用订单状态 API 获取订单信息
- 将结果传递给结果汇总智能体

**关键技术**：
- AutoGen AssistantAgent 配置
- 函数调用（Function Calling）集成
- 异步 API 调用
- 错误处理和重试机制

**`agents/logistics_query_agent.py`**: 物流查询智能体实现

**主要功能**：
- 基于 AutoGen 框架构建
- 接收订单编号作为输入
- 调用物流信息 API 获取物流数据
- 将结果传递给结果汇总智能体

**关键技术**：
- AutoGen AssistantAgent 配置
- 函数调用集成
- 异步 API 调用
- 错误处理和重试机制

**`agents/result_summary_agent.py`**: 结果汇总智能体实现

**主要功能**：
- 基于 AutoGen 框架和 OpenAI API 构建
- 接收订单查询智能体和物流查询智能体的返回结果
- 理解用户的原始查询意图
- 整合订单状态和物流信息
- 生成用户友好的自然语言回复

**关键技术**：
- AutoGen AssistantAgent 配置
- OpenAI API 集成
- 自然语言生成（NLG）
- 多源信息整合

**`agents/agent_communicator.py`**: 智能体通信管理器

**主要功能**：
- 创建和管理所有智能体
- 实现智能体之间的消息传递
- 协调智能体的任务分发
- 管理智能体的生命周期（创建、初始化、通信、销毁）
- 集成交互可视化展示功能

**关键技术**：
- AutoGen GroupChat 管理
- 消息路由和转发
- 并发任务协调
- 事件监听和可视化

#### 🌐 API 服务模块

**`api/main.py`**: FastAPI 主应用

**主要功能**：
- 配置 FastAPI 应用
- 注册路由模块
- 集成中间件
- 配置 CORS 和异常处理

**`api/routes/orders.py`**: 订单状态 API 路由

**主要功能**：
- 实现 `GET /api/v1/orders/{order_id}` 接口
- 返回订单详细状态信息
- 包含模拟数据和错误处理

**响应格式**：
```json
{
  "order_id": "ORD001",
  "created_time": "2024-01-01T10:00:00Z",
  "order_status": "待发货",
  "payment_status": "已支付",
  "shipping_status": "未发货"
}
```

**`api/routes/logistics.py`**: 物流信息 API 路由

**主要功能**：
- 实现 `GET /api/v1/logistics/{order_id}` 接口
- 返回物流跟踪信息
- 包含模拟数据和错误处理

**响应格式**：
```json
{
  "order_id": "ORD001",
  "logistics_status": "运输中",
  "current_location": "北京转运中心",
  "estimated_delivery": "3天",
  "tracking_history": [
    {
      "time": "2024-01-02T10:00:00Z",
      "status": "已发货",
      "location": "上海仓库"
    },
    {
      "time": "2024-01-03T08:00:00Z",
      "status": "运输中",
      "location": "北京转运中心"
    }
  ]
}
```

**`api/models/`**: 数据模型定义

- **`order.py`**: 订单数据模型（使用 Pydantic）
- **`logistics.py`**: 物流数据模型（使用 Pydantic）

**`api/data/`**: 模拟数据存储

- **`orders_data.py`**: 内存中的订单模拟数据
- **`logistics_data.py`**: 内存中的物流模拟数据

#### ⚙️ 配置和核心模块

**`config/settings.py`**: 统一的配置管理

**主要配置项**：
- OpenAI API 配置（API Key、模型、温度等）
- 重试机制参数（最大重试次数、初始延迟、退避因子、最大延迟）
- 日志系统配置（日志级别、日志文件路径、日志格式）
- 模拟服务配置（服务端口、CORS 设置）
- 智能体行为配置（超时时间、最大轮次）

**`config/agents.py`**: 智能体行为配置

**主要配置项**：
- 订单查询智能体的系统提示词
- 物流查询智能体的系统提示词
- 结果汇总智能体的系统提示词
- 智能体间的交互规则

**`config/retry.py`**: 重试机制配置

**主要配置项**：
- 初始延迟：1 秒
- 最大重试次数：3 次
- 退避因子：2（每次重试延迟时间翻倍）
- 最大延迟：10 秒
- 可重试的错误类型（网络错误、超时错误、服务不可用）
- 不可重试的错误类型（数据格式错误、订单不存在）

**`core/logger.py`**: 日志系统实现

**主要功能**：
- 支持文件和控制台双重输出
- UTF-8 编码支持
- 日志轮转功能（按文件大小或时间）
- 统一的日志格式（时间戳、日志级别、模块、消息）
- 分级日志记录（DEBUG、INFO、WARNING、ERROR、CRITICAL）

**`core/query_parser.py`**: 查询解析器

**主要功能**：
- 解析用户查询内容
- 提取订单编号（支持多种格式）
- 识别查询意图（订单状态查询、物流查询、综合查询）
- 输入格式转换和验证

**`core/visualizer.py`**: 交互可视化展示器

**主要功能**：
- 实时收集智能体交互消息
- 显示智能体任务执行状态（待处理、执行中、已完成）
- 展示 API 调用详细日志（时间戳、请求内容、响应内容）
- 展示重试机制执行情况（重试次数、退避时间）
- 文本流输出展示，按时间顺序展示执行过程
- 状态标识和错误提示

#### 🔧 工具和服务模块

**`tools/api_client.py`**: API 客户端工具

**主要功能**：
- 封装 HTTP 请求逻辑（使用 httpx 库）
- 提供订单状态查询接口
- 提供物流信息查询接口
- 集成重试机制
- 提供友好的错误处理
- 支持异步操作

**主要方法**：
```python
async def get_order_status(order_id: str) -> dict
async def get_logistics_info(order_id: str) -> dict
async def health_check() -> bool
```

**`services/retry_service.py`**: 重试机制服务

**主要功能**：
- 实现指数级退避策略（基于 tenacity 库）
- 可配置的重试策略（最大重试次数、初始延迟、退避因子、最大延迟）
- HTTP 错误智能判断
- 详细的重试日志

**`services/order_service.py`**: 订单查询服务

**主要功能**：
- 封装订单相关的业务逻辑
- 整合订单查询和物流查询
- 提供统一的订单查询接口

#### 🧪 测试模块

**`tests/unit/`**: 单元测试

- **`test_agents.py`**: 智能体单元测试
- **`test_api_client.py`**: API 客户端测试
- **`test_retry.py`**: 重试机制测试

**`tests/integration/`**: 集成测试

- **`test_api.py`**: API 集成测试
- **`test_workflow.py`**: 工作流集成测试

#### 📋 配置文件和文档

- **`.env.example`**: 环境变量配置模板
- **`requirements.txt`**: Python 依赖包清单
- **`项目描述.txt`**: 项目需求和技术难点说明
- **`docs/design.md`**: 架构设计文档
- **`docs/requirements.md`**: 需求规格说明书
- **`docs/tasks.md`**: 任务规划文档
- **`docs/api.md`**: API 接口文档

## 3. 运行说明

### 3.1 环境配置要求

#### 系统要求
- **操作系统**: Windows 10/11, macOS 10.14+, Linux (Ubuntu 18.04+)
- **Python 版本**: Python 3.9 或更高版本
- **内存**: 至少 4GB RAM
- **磁盘空间**: 至少 2GB 可用空间

#### 必需的外部服务
- **OpenAI API**: 需要有效的 OpenAI API 密钥（可选，用于智能体对话）
- **网络连接**: 用于 API 调用和依赖包下载

### 3.2 安装依赖步骤

#### 步骤 1: 克隆或下载项目
```bash
# 如果从 Git 仓库克隆
git clone <repository-url>
cd week1_2

# 或直接进入项目目录
cd d:\AI工程化训练营\workspace\project\project1_2
```

#### 步骤 2: 创建虚拟环境（推荐）
```bash
# 创建虚拟环境
python -m venv venv

# 激活虚拟环境
# Windows
venv\Scripts\activate
# macOS/Linux
source venv/bin/activate
```

#### 步骤 3: 安装依赖包
```bash
# 升级 pip
python -m pip install --upgrade pip

# 安装项目依赖
pip install -r requirements.txt
```

#### 步骤 4: 配置环境变量
```bash
# 复制环境变量模板
copy .env.example .env  # Windows
cp .env.example .env    # macOS/Linux

# 编辑 .env 文件，填入必要的配置
# 特别是 OPENAI_API_KEY（如果使用 OpenAI 服务）
```

### 3.3 项目启动和运行

#### 方式 1: 直接运行主程序
```bash
# 基本运行（使用默认查询）
python main.py

# 指定查询内容
python main.py --query "我的订单ORD001为什么还没发货？"

# 查看帮助信息
python main.py --help
```

#### 方式 2: 分步启动（开发调试用）
```bash
# 终端 1: 启动 FastAPI 模拟服务
python api/fastapi_server.py

# 终端 2: 运行智能体系统
python main.py --query "我的订单ORD002的物流状态如何？"
```

#### 方式 3: 交互式运行
```bash
# 启动后会提示输入查询
python main.py --interactive
```

### 3.4 测试和构建流程

#### 运行单元测试
```bash
# 运行所有测试
pytest

# 运行特定测试文件
pytest tests/test_agents.py

# 运行测试并显示覆盖率
pytest --cov=. --cov-report=html
```

#### 代码质量检查
```bash
# 代码格式化
black .

# 代码风格检查
flake8 .

# 类型检查（如果配置了 mypy）
mypy .
```

#### 构建和打包
```bash
# 生成依赖包列表
pip freeze > requirements.txt

# 创建分发包（如果需要）
python setup.py sdist bdist_wheel
```

### 3.5 常用命令示例

```bash
# 查询特定订单
python main.py --query "订单ORD001的状态如何？"

# 查询物流信息
python main.py --query "我的订单ORD002什么时候能到？"

# 启用详细日志
python main.py --query "订单查询" --log-level DEBUG

# 测试 API 连接
python -c "from tools.api_client import api_client; import asyncio; asyncio.run(api_client.health_check())"
```

## 3. 运行说明

### 3.1 环境配置要求

#### 3.1.1 系统要求

| 配置项 | 要求 |
|--------|------|
| 操作系统 | Windows 10/11, macOS 10.14+, Linux (Ubuntu 18.04+) |
| Python 版本 | Python 3.9 或更高版本 |
| 内存 | 至少 4GB RAM |
| 磁盘空间 | 至少 2GB 可用空间 |
| 网络 | 需要稳定的网络连接 |

#### 3.1.2 必需的外部服务

| 服务 | 说明 | 是否必需 |
|------|------|----------|
| OpenAI API | 用于自然语言回复生成 | 可选（如果使用模拟回复则不需要） |
| 内部 API | 模拟的订单和物流接口 | 必需（项目中内置模拟服务） |
| 网络连接 | 用于 API 调用和依赖包下载 | 必需 |

### 3.2 安装依赖步骤

#### 步骤 1: 克隆或下载项目

```bash
# 如果从 Git 仓库克隆
git clone <repository-url>
cd multi-agent-customer-system

# 或直接进入项目目录（根据实际路径）
cd /path/to/multi-agent-customer-system
```

#### 步骤 2: 创建虚拟环境（推荐）

```bash
# 创建虚拟环境
python -m venv venv

# 激活虚拟环境
# Windows
venv\Scripts\activate

# macOS/Linux
source venv/bin/activate
```

#### 步骤 3: 安装依赖包

```bash
# 升级 pip
python -m pip install --upgrade pip

# 安装项目依赖
pip install -r requirements.txt
```

#### 步骤 4: 配置环境变量

```bash
# 复制环境变量模板
# Windows
copy .env.example .env

# macOS/Linux
cp .env.example .env

# 编辑 .env 文件，填入必要的配置
# 特别是 OPENAI_API_KEY（如果使用 OpenAI 服务）
```

**`.env` 文件配置示例**：
```env
# OpenAI API 配置
OPENAI_API_KEY=your_openai_api_key_here
OPENAI_MODEL=gpt-4
OPENAI_TEMPERATURE=0.7

# API 服务配置
API_HOST=localhost
API_PORT=8000

# 重试机制配置
MAX_RETRY_TIMES=3
INITIAL_DELAY=1
MAX_DELAY=10

# 日志配置
LOG_LEVEL=INFO
LOG_FILE=logs/app.log
```

### 3.3 项目启动和运行

#### 方式 1: 直接运行主程序（推荐）

```bash
# 基本运行（使用默认查询）
python main.py

# 指定查询内容
python main.py --query "我的订单ORD001为什么还没发货？"

# 查询物流信息
python main.py --query "我的订单ORD002的物流状态如何？"

# 查看帮助信息
python main.py --help
```

#### 方式 2: 交互式运行

```bash
# 启动后会提示输入查询
python main.py --interactive

# 示例交互流程
请输入您的查询（输入 'quit' 退出）：我的订单ORD001什么时候发货？

# 系统会处理查询并显示结果

请输入您的查询（输入 'quit' 退出）quit
```

#### 方式 3: 分步启动（开发调试用）

```bash
# 终端 1: 启动 FastAPI 模拟服务
python api/main.py

# 终端 2: 运行智能体系统
python main.py --query "我的订单ORD002的物流状态如何？"
```

#### 方式 4: 使用自定义脚本启动

```bash
# 使用提供的启动脚本
# macOS/Linux
./scripts/start_api.sh

# Windows PowerShell
.\scripts\start_api.ps1
```

### 3.4 测试和构建流程

#### 运行单元测试

```bash
# 运行所有测试
pytest

# 运行特定测试文件
pytest tests/unit/test_agents.py

# 运行测试并显示详细输出
pytest -v

# 运行测试并显示覆盖率
pytest --cov=. --cov-report=html
```

#### 运行集成测试

```bash
# 运行所有集成测试
pytest tests/integration/

# 运行特定集成测试
pytest tests/integration/test_api.py

# 运行工作流集成测试
pytest tests/integration/test_workflow.py
```

#### 代码质量检查

```bash
# 代码格式化
black .

# 代码风格检查
flake8 .

# 类型检查（如果配置了 mypy）
mypy .

# 代码复杂度检查
radon cc .
```

#### 构建和打包

```bash
# 生成依赖包列表
pip freeze > requirements.txt

# 创建分发包（如果需要）
python setup.py sdist bdist_wheel

# 使用 setuptools 构建项目
python -m build
```

### 3.5 常用命令示例

#### 查询操作

```bash
# 查询特定订单
python main.py --query "订单ORD001的状态如何？"

# 查询物流信息
python main.py --query "我的订单ORD002什么时候能到？"

# 综合查询
python main.py --query "我的订单ORD003发货了吗？物流到哪了？"
```

#### 调试操作

```bash
# 启用详细日志
python main.py --query "订单查询" --log-level DEBUG

# 查看配置信息
python main.py --show-config

# 测试 API 连接
python -c "from tools.api_client import api_client; import asyncio; asyncio.run(api_client.health_check())"
```

#### 测试操作

```bash
# 测试订单查询智能体
pytest tests/unit/test_agents.py::test_order_query_agent

# 测试重试机制
pytest tests/unit/test_retry.py

# 测试 API 接口
pytest tests/integration/test_api.py
```

### 3.6 故障排查

#### 常见问题及解决方案

**问题 1：OpenAI API 连接失败**

```bash
# 解决方案：检查 API Key 配置
# 1. 确保 .env 文件中的 OPENAI_API_KEY 正确配置
# 2. 检查网络连接
# 3. 验证 API Key 是否有效
python -c "import openai; print(openai.api_key)"
```

**问题 2：API 服务启动失败**

```bash
# 解决方案：检查端口占用
# macOS/Linux
lsof -i :8000

# Windows
netstat -ano | findstr :8000

# 杀死占用端口的进程
# macOS/Linux
kill -9 <PID>

# Windows
taskkill /PID <PID> /F
```

**问题 3：智能体响应超时**

```bash
# 解决方案：调整超时配置
# 在 config/settings.py 中增加超时时间
AGENT_TIMEOUT = 60  # 增加到 60 秒
```

**问题 4：重试机制无效**

```bash
# 解决方案：检查重试配置
# 在 config/retry.py 中验证配置
MAX_RETRY_TIMES = 3
INITIAL_DELAY = 1
BACKOFF_FACTOR = 2
MAX_DELAY = 10
```

## 4. 数据流说明

### 4.1 整体数据流架构

```
用户查询 → 查询解析器 → 智能体通信管理器 → API客户端 → FastAPI服务 → 返回结果
  │           │              │              │           │           │
  ↓     main.py      agents/agent_   tools/api_   api/main   api/routes/
命令行  core/query      communicator   client.py   .py      .py
参数    parser.py           .py               │           │
                                           重试机制     数据层
                                       services/retry_   api/data/
                                       service.py        .py
```

### 4.2 详细数据流程

#### 4.2.1 阶段 1: 请求初始化

**步骤 1: 用户输入**
- 用户通过命令行传入查询字符串
- 或使用交互式模式输入查询

**步骤 2: 参数解析**
- `main.py` 使用 `argparse` 解析命令行参数
- 提取查询内容、日志级别等配置

**步骤 3: 服务启动**
- 检查 FastAPI 模拟服务是否已运行
- 如果未运行，自动启动 API 服务

**步骤 4: 智能体初始化**
- 创建订单查询智能体
- 创建物流查询智能体
- 创建结果汇总智能体
- 初始化智能体通信管理器

**步骤 5: 查询解析**
- `core/query_parser.py` 解析用户查询内容
- 提取订单编号（如 ORD001）
- 识别查询意图（订单状态查询、物流查询、综合查询）

#### 4.2.2 阶段 2: 智能体协作处理

**步骤 1: 查询分发**
- 智能体通信管理器接收解析后的查询
- 将查询分发给订单查询智能体和物流查询智能体

**步骤 2: 任务分解**
- 智能体系统识别需要执行的任务类型
- 确定并行执行的策略（订单查询和物流查询可并行）

**步骤 3: 并行处理**

**订单查询智能体处理流程**：
```
1. 接收订单ID（如 ORD001）
2. 调用 tools/api_client.get_order_status(order_id)
3. API 客户端发送 GET /api/v1/orders/ORD001 请求
4. 如果请求失败，触发重试机制
5. 接收订单状态信息（JSON 格式）
6. 在交互可视化展示器中记录执行过程
```

**物流查询智能体处理流程**：
```
1. 接收订单ID（如 ORD001）
2. 调用 tools/api_client.get_logistics_info(order_id)
3. API 客户端发送 GET /api/v1/logistics/ORD001 请求
4. 如果请求失败，触发重试机制
5. 接收物流跟踪信息（JSON 格式）
6. 在交互可视化展示器中记录执行过程
```

**步骤 4: 结果汇总**
- 结果汇总智能体收集前两个智能体的结果
- 理解用户的原始查询意图
- 整合订单状态和物流信息
- 生成自然语言回复

#### 4.2.3 阶段 3: API 调用和数据获取

**步骤 1: HTTP 请求**
- API 客户端使用 httpx 发送异步 HTTP 请求
- 请求头包含 Content-Type: application/json

**步骤 2: 重试机制**
- 使用 `services/retry_service.py` 实现指数退避重试
- 可重试的错误：网络错误、超时错误、服务不可用
- 不可重试的错误：数据格式错误、订单不存在（404）

**重试配置**：
```python
MAX_RETRY_TIMES = 3
INITIAL_DELAY = 1  # 秒
BACKOFF_FACTOR = 2  # 延迟翻倍
MAX_DELAY = 10     # 最大延迟
```

**重试示例**：
```
第 1 次尝试 → 失败 → 等待 1 秒
第 2 次尝试 → 失败 → 等待 2 秒
第 3 次尝试 → 失败 → 等待 4 秒
第 4 次尝试 → 失败 → 返回错误
```

**步骤 3: 数据解析**
- 将 JSON 响应解析为 Python 字典
- 使用 Pydantic 模型验证数据格式
- 处理数据转换和类型转换

**步骤 4: 错误处理**
- 记录详细的错误日志
- 提供友好的错误提示
- 根据错误类型决定是否重试

#### 4.2.4 阶段 4: 结果返回和展示

**步骤 1: 数据整合**
- 结果汇总智能体将订单信息、物流信息和用户意图整合
- 生成结构化的回复数据

**步骤 2: 格式化输出**
- 使用 Rich 库创建美观的命令行界面展示
- 使用彩色输出和格式化表格

**步骤 3: 日志记录**
- 记录整个处理过程的详细日志
- 包括智能体交互、API 调用、错误处理等

**步骤 4: 用户反馈**
- 向用户展示最终的查询结果
- 展示智能体的交互过程（如果启用了可视化）

### 4.3 主要模块间的交互方式

#### 4.3.1 AutoGen 智能体通信协议

**消息格式**：
```python
{
    "role": "user|assistant|system",
    "content": "消息内容",
    "name": "智能体名称",
    "function_call": {
        "name": "函数名",
        "arguments": "参数"
    }
}
```

**消息类型**：
1. **任务分发消息**：从通信管理器发送给查询智能体
2. **查询请求消息**：查询智能体发送给 API 客户端
3. **结果返回消息**：API 客户端返回给查询智能体
4. **状态同步消息**：智能体之间同步执行状态
5. **汇总请求消息**：结果汇总智能体请求查询智能体的结果

#### 4.3.2 API 请求协议

**订单状态 API 请求**：
```http
GET /api/v1/orders/ORD001 HTTP/1.1
Host: localhost:8000
Content-Type: application/json
```

**订单状态 API 响应**：
```json
{
  "order_id": "ORD001",
  "created_time": "2024-01-01T10:00:00Z",
  "order_status": "待发货",
  "payment_status": "已支付",
  "shipping_status": "未发货"
}
```

**物流信息 API 请求**：
```http
GET /api/v1/logistics/ORD001 HTTP/1.1
Host: localhost:8000
Content-Type: application/json
```

**物流信息 API 响应**：
```json
{
  "order_id": "ORD001",
  "logistics_status": "运输中",
  "current_location": "北京转运中心",
  "estimated_delivery": "3天",
  "tracking_history": [
    {
      "time": "2024-01-02T10:00:00Z",
      "status": "已发货",
      "location": "上海仓库"
    },
    {
      "time": "2024-01-03T08:00:00Z",
      "status": "运输中",
      "location": "北京转运中心"
    }
  ]
}
```

#### 4.3.3 重试机制协议

**重试触发条件**：
- 网络连接错误（httpx.ConnectError）
- 请求超时（httpx.TimeoutException）
- 服务器错误（HTTP 500、502、503、504）
- 连接超时（httpx.ConnectTimeout）

**不重试条件**：
- 客户端错误（HTTP 400、404、422）
- 数据格式错误（JSON 解析失败）
- 订单不存在（返回 404 状态码）

**重试策略**：
- 采用指数级退避策略
- 每次重试延迟时间 = min(INITIAL_DELAY * (BACKOFF_FACTOR ** retry_count), MAX_DELAY)
- 记录每次重试的详细信息

#### API 调用接口规范
```python
# 订单查询接口
GET /api/orders/{order_id}
Response: {
    "order_id": "ORD001",
    "status": "processing|shipped|delivered",
    "customer_name": "客户姓名",
    "total_amount": 299.99,
    "items": ["商品列表"],
    "shipping_address": "配送地址",
    "created_at": "创建时间",
    "updated_at": "更新时间",
    "estimated_delivery": "预计送达时间"
}

# 物流查询接口
GET /api/logistics/{order_id}
Response: {
    "order_id": "ORD001",
    "tracking_number": "快递单号",
    "status": "not_shipped|in_transit|out_for_delivery|delivered",
    "current_location": "当前位置",
    "carrier": "承运商",
    "estimated_delivery": "预计送达时间",
    "tracking_history": [
        {
            "time": "时间",
            "location": "地点",
            "status": "状态"
        }
    ]
}
```

### 4.4 关键API调用和数据转换

#### 重试机制实现
```python
@create_retry_decorator(max_attempts=3, min_wait=1.0, max_wait=10.0)
async def api_call():
    # 指数退避: 1s → 2s → 4s → 8s
    # 最大等待时间: 10s
    # 最大重试次数: 3次
```

#### 数据转换流程
1. **原始查询** → **订单ID提取** → **API调用参数**
2. **JSON响应** → **Python字典** → **智能体消息格式**
3. **多个API结果** → **整合数据** → **用户友好文本**

#### 异步处理机制
- 使用 `asyncio` 实现并发API调用
- 智能体可以并行处理不同的任务
- 非阻塞的用户界面更新

## 5. 业务场景示例

### 5.1 场景一：查询订单发货延迟

**用户提问**: "我的订单ORD001为什么还没发货？"

**系统处理流程**:

1. **查询解析器**分析查询内容
   - 识别订单编号：ORD001
   - 识别查询意图：订单状态查询

2. **智能体协同处理**

   **订单查询智能体执行**:
   ```
   [订单查询智能体] 开始查询订单 ORD001 的状态...
   [API 客户端] 发送请求: GET /api/v1/orders/ORD001
   [API 客户端] 接收响应: {"order_id":"ORD001","order_status":"待发货","payment_status":"已支付","shipping_status":"未发货"}
   [订单查询智能体] 查询完成，订单状态为"待发货"，支付状态为"已支付"
   ```

   **物流查询智能体执行**:
   ```
   [物流查询智能体] 开始查询订单 ORD001 的物流信息...
   [API 客户端] 发送请求: GET /api/v1/logistics/ORD001
   [API 客户端] 接收响应: {"order_id":"ORD001","logistics_status":"待发货","tracking_history":[]}
   [物流查询智能体] 查询完成，暂无物流信息，订单未发货
   ```

   **结果汇总智能体执行**:
   ```
   [结果汇总智能体] 收集订单和物流信息
   [结果汇总智能体] 理解用户查询意图：询问为什么还没发货
   [结果汇总智能体] 生成回复...
   ```

3. **最终输出**

```
✅ 查询完成

【订单信息】
- 订单编号：ORD001
- 订单状态：待发货
- 支付状态：已支付
- 发货状态：未发货

【物流信息】
- 物流状态：待发货
- 当前位置：暂无物流信息

【智能回复】
您的订单ORD001已经完成支付，但尚未发货。当前订单状态为"待发货"，请您耐心等待，我们会尽快为您安排发货。预计发货时间为1-2个工作日内。
```

### 5.2 场景二：查询物流跟踪

**用户提问**: "我的订单ORD002的物流状态如何？"

**系统处理流程**:

1. **查询解析器**分析查询内容
   - 识别订单编号：ORD002
   - 识别查询意图：物流信息查询

2. **智能体协同处理**

   **订单查询智能体执行**:
   ```
   [订单查询智能体] 查询订单 ORD002 的状态...
   [API 客户端] 接收响应: {"order_id":"ORD002","order_status":"已发货","payment_status":"已支付","shipping_status":"已发货"}
   ```

   **物流查询智能体执行**:
   ```
   [物流查询智能体] 查询订单 ORD002 的物流信息...
   [API 客户端] 接收响应: {
     "order_id":"ORD002",
     "logistics_status":"运输中",
     "current_location":"北京转运中心",
     "estimated_delivery":"3天",
     "tracking_history":[
       {"time":"2024-01-02T10:00:00Z","status":"已发货","location":"上海仓库"},
       {"time":"2024-01-03T08:00:00Z","status":"运输中","location":"北京转运中心"}
     ]
   }
   ```

   **结果汇总智能体执行**:
   ```
   [结果汇总智能体] 整合订单和物流信息
   [结果汇总智能体] 生成回复...
   ```

3. **最终输出**

```
✅ 查询完成

【订单信息】
- 订单编号：ORD002
- 订单状态：已发货
- 支付状态：已支付
- 发货状态：已发货

【物流信息】
- 物流状态：运输中
- 当前位置：北京转运中心
- 预计送达：3天

【物流轨迹】
1. 2024-01-02 10:00:00 - 已发货 - 上海仓库
2. 2024-01-03 08:00:00 - 运输中 - 北京转运中心

【智能回复】
您的订单ORD002已发货，物流状态为"运输中"。包裹当前到达北京转运中心，预计3天后送达您手中。您可以继续关注物流信息或稍后再次查询。
```

### 5.3 场景三：综合查询订单和物流

**用户提问**: "我的订单ORD003发货了吗？物流到哪了？"

**系统处理流程**:

1. **查询解析器**分析查询内容
   - 识别订单编号：ORD003
   - 识别查询意图：综合查询（订单状态 + 物流信息）

2. **智能体协同处理**
   - 订单查询智能体和物流查询智能体并行执行
   - 结果汇总智能体整合两方面的信息

3. **最终输出**

```
✅ 查询完成

【订单信息】
- 订单编号：ORD003
- 订单状态：已发货
- 支付状态：已支付
- 发货状态：已发货

【物流信息】
- 物流状态：派送中
- 当前位置：北京市朝阳区
- 预计送达：今天

【物流轨迹】
1. 2024-01-04 10:00:00 - 已发货 - 上海仓库
2. 2024-01-04 15:00:00 - 运输中 - 北京转运中心
3. 2024-01-05 08:00:00 - 派送中 - 北京市朝阳区

【智能回复】
好消息！您的订单ORD003已经发货，并且正在派送中。包裹目前位于北京市朝阳区，预计今天就能送达您的手中。请保持手机畅通，配送员会联系您。有任何问题可以随时联系我们。
```

## 6. 开发指南

### 6.1 添加新的智能体

**步骤 1: 创建智能体文件**

在 `agents/` 目录下创建新的智能体文件，例如 `refund_query_agent.py`：

```python
from autogen import AssistantAgent
from config.settings import settings

class RefundQueryAgent:
    """退款查询智能体"""
    
    def __init__(self, api_client):
        self.api_client = api_client
        self.agent = self._create_agent()
    
    def _create_agent(self):
        """创建退款查询智能体"""
        return AssistantAgent(
            name="refund_query_agent",
            llm_config=settings.get_llm_config(),
            system_message="""你是一个专业的退款查询智能体。
            你的职责是：
            1. 接收用户提出的退款申请
            2. 查询退款的处理状态和退款进度
            3. 将退款信息传递给结果汇总智能体
            """,
            function_map={
                "query_refund_status": self.query_refund_status
            }
        )
    
    async def query_refund_status(self, order_id: str) -> dict:
        """查询退款状态"""
        try:
            # 调用退款 API
            refund_info = await self.api_client.get_refund_info(order_id)
            return {
                "order_id": order_id,
                "refund_status": refund_info["status"],
                "refund_amount": refund_info["amount"],
                "refund_time": refund_info["refund_time"]
            }
        except Exception as e:
            return {
                "error": str(e),
                "order_id": order_id
            }
```

**步骤 2: 注册智能体**

在 `agents/__init__.py` 中导出新智能体：

```python
from .refund_query_agent import RefundQueryAgent

__all__ = [
    "OrderQueryAgent",
    "LogisticsQueryAgent",
    "ResultSummaryAgent",
    "RefundQueryAgent"  # 添加新智能体
]
```

**步骤 3: 在智能体通信管理器中注册**

在 `agents/agent_communicator.py` 中添加新智能体的注册：

```python
from .refund_query_agent import RefundQueryAgent

class AgentCommunicator:
    def __init__(self, api_client):
        self.agents = {}
        self._initialize_agents(api_client)
    
    def _initialize_agents(self, api_client):
        """初始化所有智能体"""
        # 已有的智能体
        self.agents["order_query"] = OrderQueryAgent(api_client)
        self.agents["logistics_query"] = LogisticsQueryAgent(api_client)
        self.agents["result_summary"] = ResultSummaryAgent()
        
        # 添加新智能体
        self.agents["refund_query"] = RefundQueryAgent(api_client)
```

### 6.2 添加新的 API 接口

**步骤 1: 创建数据模型**

在 `api/models/` 目录下创建新的数据模型：

```python
# api/models/refund.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class RefundInfo(BaseModel):
    """退款信息模型"""
    order_id: str
    refund_status: str
    refund_amount: float
    refund_time: Optional[datetime] = None
    refund_reason: Optional[str] = None
    
    class Config:
        json_schema_extra = {
            "example": {
                "order_id": "ORD001",
                "refund_status": "退款中",
                "refund_amount": 299.00,
                "refund_time": "2024-01-05T10:00:00Z",
                "refund_reason": "商品质量问题"
            }
        }
```

**步骤 2: 创建路由**

在 `api/routes/` 目录下创建新的路由文件：

```python
# api/routes/refund.py
from fastapi import APIRouter, HTTPException
from ..models.refund import RefundInfo
from ..data.refund_data import refund_data

router = APIRouter(prefix="/api/v1/refunds", tags=["Refunds"])

@router.get("/{order_id}", response_model=RefundInfo)
async def get_refund_info(order_id: str):
    """获取退款信息"""
    if order_id not in refund_data:
        raise HTTPException(status_code=404, detail="退款信息不存在")
    
    return refund_data[order_id]
```

**步骤 3: 创建模拟数据**

在 `api/data/` 目录下创建模拟数据：

```python
# api/data/refund_data.py
from datetime import datetime

refund_data = {
    "ORD001": {
        "order_id": "ORD001",
        "refund_status": "退款中",
        "refund_amount": 299.00,
        "refund_time": datetime(2024, 1, 5, 10, 0, 0),
        "refund_reason": "商品质量问题"
    },
    "ORD002": {
        "order_id": "ORD002",
        "refund_status": "已退款",
        "refund_amount": 599.00,
        "refund_time": datetime(2024, 1, 3, 15, 30, 0),
        "refund_reason": "用户主动取消"
    }
}
```

**步骤 4: 注册路由**

在 `api/main.py` 中注册新路由：

```python
from fastapi import FastAPI
from .routes.orders import router as orders_router
from .routes.logistics import router as logistics_router
from .routes.refund import router as refund_router  # 导入新路由

app = FastAPI(title="Multi-Agent Customer System API")

app.include_router(orders_router)
app.include_router(logistics_router)
app.include_router(refund_router)  # 注册新路由
```

### 6.3 自定义重试策略

创建自定义的重试策略类：

```python
# utils/custom_retry.py
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
    before_sleep_log
)
import logging

logger = logging.getLogger(__name__)

class CustomRetryStrategy:
    """自定义重试策略"""
    
    def __init__(
        self,
        max_attempts: int = 3,
        initial_wait: float = 1.0,
        max_wait: float = 10.0,
        exponential_base: int = 2
    ):
        self.max_attempts = max_attempts
        self.initial_wait = initial_wait
        self.max_wait = max_wait
        self.exponential_base = exponential_base
    
    def get_retry_decorator(self, retryable_exceptions):
        """获取重试装饰器"""
        return retry(
            stop=stop_after_attempt(self.max_attempts),
            wait=wait_exponential(
                multiplier=self.initial_wait,
                max=self.max_wait,
                exp_base=self.exponential_base
            ),
            retry=retry_if_exception_type(retryable_exceptions),
            before_sleep=before_sleep_log(logger, logging.WARNING),
            reraise=True
        )

# 使用示例
from httpx import ConnectError, TimeoutException

retry_strategy = CustomRetryStrategy(
    max_attempts=5,
    initial_wait=2.0,
    max_wait=30.0
)

@retry_strategy.get_retry_decorator((ConnectError, TimeoutException))
async def custom_api_call():
    # 你的 API 调用逻辑
    pass
```

## 7. 扩展指南

### 7.1 扩展为 Web 应用

可以将当前的命令行界面扩展为 Web 应用，使用 FastAPI + Vue.js 或 React：

**后端扩展**：

```python
# api/web_interface.py
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

app = FastAPI(title="Multi-Agent Customer System Web API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class QueryRequest(BaseModel):
    query: str
    session_id: str

@app.post("/api/query")
async def handle_query(request: QueryRequest):
    """处理查询请求"""
    from agents.agent_communicator import AgentCommunicator
    from tools.api_client import APIClient
    
    api_client = APIClient()
    communicator = AgentCommunicator(api_client)
    result = await communicator.process_query(request.query)
    return result

@app.websocket("/ws/query")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket 实时查询接口"""
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_text()
            # 处理查询并返回流式响应
            await websocket.send_json({"message": "Processing..."})
    except Exception as e:
        await websocket.close()
```

**前端扩展**：

创建 Vue.js 或 React 应用，提供图形化界面。

### 7.2 集成到现有客服系统

可以通过以下方式集成到现有客服系统：

1. **API 网关集成**：将系统的 API 接口注册到 API 网关
2. **消息队列集成**：使用消息队列（如 RabbitMQ、Kafka）处理异步查询
3. **数据库集成**：将查询历史和结果存储到数据库
4. **监控告警集成**：集成到 Prometheus + Grafana监控系统

### 7.3 支持多语言

扩展系统以支持多语言查询和回复：

```python
# utils/i18n.py
from typing import Dict

class TranslationService:
    """翻译服务"""
    
    TRANSLATIONS: Dict[str, Dict[str, str]] = {
        "zh-CN": {
            "order_status": "订单状态",
            "logistics_info": "物流信息",
            "query_completed": "查询完成"
        },
        "en-US": {
            "order_status": "Order Status",
            "logistics_info": "Logistics Information",
            "query_completed": "Query Completed"
        }
    }
    
    @classmethod
    def translate(cls, text: str, lang: str = "zh-CN") -> str:
        """翻译文本"""
        return cls.TRANSLATIONS.get(lang, {}).get(text, text)
```

## 8. 最佳实践

### 8.1 智能体设计原则

1. **单一职责**：每个智能体只负责一个明确的任务
2. **清晰接口**：定义清晰的输入输出接口
3. **可测试性**：确保智能体可以独立测试
4. **错误处理**：实现完善的错误处理和日志记录
5. **性能优化**：避免不必要的重复计算和 API 调用

### 8.2 API 设计原则

1. **RESTful 设计**：遵循 RESTful API 设计规范
2. **版本控制**：API 路径包含版本号（如 `/api/v1/orders`）
3. **错误处理**：返回标准化的错误响应
4. **文档完善**：提供完整的 API 文档（使用 Swagger/OpenAPI）
5. **安全考虑**：实现认证和授权机制

### 8.3 代码质量保证

1. **代码格式化**：使用 Black 统一代码格式
2. **类型注解**：使用 Python 类型注解提高代码可读性
3. **单元测试**：为每个模块编写单元测试
4. **集成测试**：编写端到端的集成测试
5. **代码审查**：建立代码审查流程

### 8.4 性能优化建议

1. **异步处理**：使用 asyncio 提高并发性能
2. **缓存机制**：对频繁访问的数据实现缓存
3. **连接池**：使用 HTTP 连接池减少连接开销
4. **批处理**：对批量操作实现批处理机制
5. **监控**：实现性能监控和告警机制

## 9. 相关文档

### 9.1 项目文档

| 文档名称 | 路径 | 说明 |
|---------|------|------|
| 需求规格说明书 | `cosmect/multi-agent-customer-system/requirements.md` | 详细的功能需求和非功能需求 |
| 架构设计文档 | `cosmect/multi-agent-customer-system/design.md` | 系统架构设计和接口设计 |
| 任务规划文档 | `cosmect/multi-agent-customer-system/tasks.md` | 开发任务清单和实施计划 |
| 项目描述 | `项目描述.txt` | 项目背景和技术难点说明 |

### 9.2 技术文档

| 技术组件 | 文档链接 |
|---------|---------|
| AutoGen | https://microsoft.github.io/autogen/ |
| FastAPI | https://fastapi.tiangolo.com/ |
| Pydantic | https://docs.pydantic.dev/ |
| Tenacity | https://tenacity.readthedocs.io/ |
| Rich | https://rich.readthedocs.io/ |

### 9.3 参考资料

1. **多智能体系统设计模式**
   - 参考论文：Multi-Agent Systems: A Survey
   - 实践指南：Building Multi-Agent Systems with AutoGen

2. **自然语言处理**
   - OpenAI API 最佳实践
   - Prompt Engineering 指南

3. **系统架构**
   - 微服务架构设计模式
   - 事件驱动架构实践

## 10. 附录

### 10.1 术语表

| 术语 | 英文 | 说明 |
|------|------|------|
| 智能体 | Agent | 具有自主行为和决策能力的软件实体 |
| 多智能体系统 | Multi-Agent System | 由多个智能体组成的协作系统 |
| 指数退避 | Exponential Backoff | 一种重试策略，每次重试的等待时间指数级增长 |
| 消息传递 | Message Passing | 智能体之间交换信息的机制 |
| 函数调用 | Function Calling | 智能体调用预定义函数的能力 |
| 查询意图 | Query Intent | 用户查询的真实目的和需求 |

### 10.2 常见问题解答（FAQ）

**Q1: 如何添加新的查询类型？**

A: 按照 6.1 节"添加新的智能体"的步骤，创建新的智能体和相应的 API 接口，然后在智能体通信管理器中注册。

**Q2: 如何调整重试策略？**

A: 修改 `config/retry.py` 中的配置参数，或按照 6.3 节"自定义重试策略"创建自定义重试策略。

**Q3: 如何提高查询响应速度？**

A: 参考 8.4 节"性能优化建议"，实现缓存机制、使用异步处理、优化 API 调用等。

**Q4: 如何处理智能体之间的冲突？**

A: 在智能体通信管理器中实现冲突检测和解决机制，可以使用优先级、协同决策等策略。

**Q5: 如何监控智能体的执行过程？**

A: 使用 `core/visualizer.py` 中的交互可视化展示器，或集成第三方监控工具（如 Prometheus）。

### 10.3 更新日志

| 版本 | 日期 | 更新内容 |
|------|------|---------|
| v1.0.0 | 2024-01-01 | 初始版本，实现基础功能 |
| v1.1.0 | 2024-01-15 | 添加智能体交互可视化功能 |
| v1.2.0 | 2024-02-01 | 优化重试机制和错误处理 |
| v1.3.0 | 2024-02-15 | 扩展文档和开发指南 |

---

**文档版本**: v1.3.0
**最后更新**: 2024-01-04
**维护者**: 开发团队
**联系方式**: support@example.com

